// Generated by CoffeeScript 1.4.0
(function() {
  var addGeoms, cacheInterval, cachePosition, comparePosition, deviceName, geolocation, getFrom, getGeos, history, lastSentPosition, lineLayer, loggedIn, login, map, onPosition, pointLayer, rotateIcons, socket, tracking, updateHistory, _geolocation;

  comparePosition = function(p1, p2) {
    var lat1, lat2, lng1, lng2, _ref, _ref1;
    if (!(p1 != null) || !(p2 != null)) {
      return false;
    }
    _ref = p1.coords, lat1 = _ref.latitude, lng1 = _ref.longitude;
    _ref1 = p2.coords, lat2 = _ref1.latitude, lng2 = _ref1.longitude;
    return lat1.toFixed(4) === lat2.toFixed(4) && lng1.toFixed(4) === lng2.toFixed(4);
  };

  onPosition = function() {};

  _geolocation = function(callback) {
    return navigator.geolocation.getCurrentPosition(callback, function(err) {
      return console.error("Error when retrieving location '" + err.message + "'.");
    });
  };

  geolocation = function(callback) {
    if (typeof lastPosition !== "undefined" && lastPosition !== null) {
      return callback(lastPosition);
    } else {
      return _geolocation(callback);
    }
  };

  cachePosition = function() {
    return _geolocation(function(position) {
      var lastPosition;
      lastPosition = position;
      return onPosition(position);
    });
  };

  socket = io.connect('/');

  socket.on('new geo', function(geoJson) {
    return addGeoms(geoJson);
  });

  tracking = false;

  deviceName = localStorage.getItem('device-name');

  if (deviceName != null) {
    $('#device-name').val(deviceName);
  }

  cacheInterval = null;

  login = function(name) {
    deviceName = name;
    localStorage.setItem('device-name', name);
    tracking = true;
    cachePosition();
    return cacheInterval = setInterval(cachePosition, 5000);
  };

  loggedIn = function() {
    return (!!deviceName) && tracking;
  };

  $('#start-position').click(function() {
    return login($('#device-name').val());
  });

  $('#start-position input[type=text]').click(function(e) {
    return e.stopPropagation();
  });

  lastSentPosition = null;

  onPosition = function(position) {
    var geoJson, lat, lng, _ref;
    if (loggedIn() && !comparePosition(lastSentPosition, position)) {
      _ref = position.coords, lat = _ref.latitude, lng = _ref.longitude;
      geoJson = {
        geometry: {
          type: 'Point',
          coordinates: [lng, lat]
        },
        properties: {
          name: deviceName,
          accuracy: position.accuracy,
          heading: position.heading,
          timestamp: Date.now(),
          hdop: -1,
          web: true
        }
      };
      socket.emit('new geo', geoJson);
      lastSentPosition = position;
      return addGeoms(geoJson);
    }
  };

  getGeos = function(query, callback) {
    return $.ajax({
      type: 'GET',
      url: '/geo',
      data: {
        q: JSON.stringify(query),
        sort: JSON.stringify('meta.timestamp')
      },
      success: function(json, status, xhr) {
        return callback(JSON.parse(json));
      }
    });
  };

  history = {};

  addGeoms = function(features) {
    var coordinates, f, line, properties, _i, _len, _ref;
    if (!(features instanceof Array)) {
      features = [features];
    }
    for (_i = 0, _len = features.length; _i < _len; _i++) {
      f = features[_i];
      (_ref = f.geometry, coordinates = _ref.coordinates), properties = f.properties;
      line = history[properties.name] || (history[properties.name] = L.polyline([]).addTo(lineLayer));
      line.addLatLng(new L.LatLng(coordinates[1], coordinates[0]));
      line.lastFeature = f;
    }
    return updateHistory();
  };

  updateHistory = function() {
    var icon, lastLatLng, latlngs, line, meta, name, p;
    for (name in history) {
      line = history[name];
      latlngs = line.getLatLngs();
      lastLatLng = latlngs[latlngs.length - 1];
      meta = line.lastFeature.properties;
      if (!(line._point != null)) {
        icon = L.icon({
          iconUrl: 'img/arrow.png',
          iconSize: [42, 42],
          iconAnchor: [21, 21],
          popupAnchor: [0, -25]
        });
        line._point = L.marker(lastLatLng, {
          icon: icon
        }).addTo(pointLayer);
      }
      p = line._point;
      p.setLatLng(lastLatLng);
      p.bindPopup("" + name + "<br>" + meta._created);
      p._heading = meta.heading || 45;
    }
    return rotateIcons();
  };

  rotateIcons = function() {
    return pointLayer.eachLayer(function(layer) {
      var icon;
      if (layer._heading != null) {
        icon = $(layer._icon);
        return icon.css('-webkit-transform', "" + (icon.css('-webkit-transform')) + " rotate(" + layer._heading + "deg)");
      }
    });
  };

  map = L.map('map');

  L.tileLayer('http://{s}.tile.cloudmade.com/4e8589a3643448ff8f36c1def19fbd8c/997/256/{z}/{x}/{y}.png', {
    attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://cloudmade.com">CloudMade</a>',
    maxZoom: 18
  }).addTo(map);

  map.on('zoomend', function() {
    return rotateIcons();
  });

  lineLayer = L.layerGroup();

  pointLayer = L.layerGroup().addTo(map);

  getFrom = new Date();

  getFrom.setHours(0, 0, 0, 0);

  getGeos({
    created: {
      $gt: getFrom
    }
  }, function(geoJson) {
    var line, name;
    addGeoms(geoJson.features);
    try {
      return map.fitBounds(new L.LatLngBounds((function() {
        var _results;
        _results = [];
        for (name in history) {
          line = history[name];
          _results.push(line._point.getLatLng());
        }
        return _results;
      })()));
    } catch (err) {
      return geolocation(function(position) {
        var lat, lng, _ref;
        _ref = position.coords, lat = _ref.latitude, lng = _ref.longitude;
        return map.setView([lat, lng], 13);
      });
    }
  });

  if (location.hash === '#tracking') {
    $('#start-position').removeClass('nodisplay');
  }

}).call(this);
